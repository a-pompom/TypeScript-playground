# 概要

Jestの肩慣らしとして、Fizz Buzzのテストコードを書いてみます。

## ゴール

複数のテストケースを効率良く検証する方法として、パラメータ化テストの書き方を理解することを目指します。

## 目次

[toc]


## つくりたいもの

[Fizz Buzz]と呼ばれる簡単なゲームをつくってみます。ルールは至ってシンプルで、以下の4つで述べられます。

* 1から順に数値をカウントアップ
* 参照している数値が3で割り切れるときは`fizz`と言う
* 参照している数値が5で割り切れるときは`buzz`と言う
* 参照している数値が15で割り切れるときは`fizz buzz`と言う

一言で表現すると、数値が3・5・15で割り切れるときは特定のメッセージを、それ以外は数値自身を出力する、といった感じでしょうか。

Hello Worldの例では単一の出力をテストコードで表現できれば十分でした。
ですが、FizzBuzzゲームでは出力が条件に応じてさまざまなものに変化します。入力の数値が3で割り切れるとき・5で割り切れるとき...それぞれを考慮しなければなりません。
条件によって出力が変わる処理をどのように検証するのか、考えていきましょう。

## Fizz Buzz関数

ここでは話を簡単にするために、FizzBuzzゲームを「数値が入力として与えられると対応するメッセージを出力する関数」として扱います。
こうすることで、今回の目的である出力が入力によって変わるような処理をどのように検証するか、ということに集中することができます。

なんだか難しそうに見えますが、処理自体はシンプルなものなので、実装コードを見ればやりたいことも見えてくるはずです。

```TypeScript
// src/fizzBuzz.ts

type FizzBuzzMessage = 'Fizz' | 'Buzz' | 'FizzBuzz!!' | number;

// 割る数
const DIVISOR_FIZZ = 3;
const DIVISOR_BUZZ = 5;
const DIVISOR_FIZZBUZZ = 15;

/**
 * 数値に応じたFizzBuzzメッセージを生成
 *
 * @param value 入力値
 */
export const fizzBuzz = (value: number): FizzBuzzMessage => {

    // 15で割り切れる
    if (value % DIVISOR_FIZZBUZZ === 0) {
        return 'FizzBuzz!!';
    }
    // 3で割り切れる
    if (value % DIVISOR_FIZZ === 0) {
        return 'Fizz';
    }
    // 5で割り切れる
    if (value % DIVISOR_BUZZ === 0) {
        return 'Buzz';
    }

    // メッセージの条件に合致しない場合は入力の数値をそのまま出力
    return value;
};
```

if文が加わったことで、関数から出力されるものが4パターンに増えました。
どんなテストコードを書けばこのような関数が期待通りに動いていることを保証できるのか、探っていきます。


## テストコード

Fizz Buzz関数のテストコードを書いてみます。Hello Worldと比べてみると、条件が色々と増えてなにやら難しそうです。
ですが、`条件1つ1つに対してテストコードを書く`と意識すれば、シンプルに考えられます。

論より証拠ということで、3で割り切れる数が入力して与えられた場合、メッセージ`Fizz`が出力として得られるか検証するテストコードを見てみましょう。

```TypeScript
// tests/fizzBuzz.test.ts

import {fizzBuzz} from 'Jest/fizzBuzz/src/fizzBuzz';

// 単一の入力をもとに検証
describe('Fizz Buzz Single', () => {

    // 3で割り切れる数はFizzが得られるか
    test('Fizz', () => {
        // GIVEN
        const sut = fizzBuzz;
        const value = 3;
        const expected = 'Fizz';
        // WHEN
        const actual = sut(value);
        // THEN
        expect(actual).toBe(expected);
    });
});
```

Hello World関数をテストしたときと同じような流れであることが分かります。
最初にテスト対象と入力、そして期待を定義します。そしてテスト対象を呼び出して得られた出力と期待値を比較し、一致したことをもってテストの成功とみなしています。

どうやらFizz Buzz関数も1つの条件に着目すれば、問題なくテストコードを書いていけそうです。

### パラメータ化テスト

しかし、1つ問題があります。
今回のテストコードは、3で割り切れる数値が入力であった場合を想定しています。そうなると、入力値`3`が動いてくれただけでは、6や9、33といった別の数値でも同じように動作するのか分かりません。
これではテストコードの信頼性が薄れてしまいます。

---

そこで、パラメータ化テストと呼ばれる手法を導入します。
文字通り、テストコードにパラメータ(引数)を導入することで、さまざまなパターンのテストコードがまとめて書けるようになります。



ジェネリクスが使えるのがよさそう。
[参考](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jest/index.d.ts)

#### 補足: なぜすべての条件を1つのパラメータ化テストで書かないのか

## まとめ